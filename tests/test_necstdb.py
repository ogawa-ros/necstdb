import struct
from pathlib import Path

import numpy as np
import pandas as pd
import pytest

import necstdb

TIME = 1630042892.423945


DATA1 = ([i, -16, -32, -64] for i in range(11))
DATA1_HEADER = {
    "data": [
        {"key": "int8", "format": "b", "size": 1},
        {"key": "int16", "format": "h", "size": 2},
        {"key": "int32", "format": "i", "size": 4},
        {"key": "int64", "format": "q", "size": 8},
    ],
    "memo": "Generated by test_necstdb.",
    "necstdb-version": necstdb.__version__,
}
DATA2 = ([i, 16, 32, 64] for i in range(22))
DATA2_HEADER = {
    "data": [
        {"key": "uint8", "format": "B", "size": 1},
        {"key": "uint16", "format": "H", "size": 2},
        {"key": "uint32", "format": "I", "size": 4},
        {"key": "uint64", "format": "Q", "size": 8},
    ],
    "memo": "Generated by test_necstdb.",
    "necstdb-version": necstdb.__version__,
}
DATA3 = ([0.32, i, b"byte", b"c"] for i in range(33))
DATA3_HEADER = {
    "data": [
        {"key": "float32", "format": "f", "size": 4},
        {"key": "float64", "format": "d", "size": 8},
        # The following 2 data types have been supported by ROS but are now deprecated.
        {"key": "_byte", "format": "4s", "size": 5},
        {"key": "_char", "format": "c", "size": 1},
    ],
    "memo": "Generated by test_necstdb.",
    "necstdb-version": necstdb.__version__,
}
DATA4 = ([True, b"str", [i, TIME, TIME]] for i in range(44))
DATA4_HEADER = {
    "data": [
        {"key": "bool", "format": "?", "size": 1},
        {"key": "string", "format": "3s", "size": 6},
        # Array data.
        {"key": "array", "format": "3d", "size": 24},
    ]
}
DATA5 = ([[b"abc", b"def", b"ghi"], b"jkl"] for _ in range(55))
DATA5_HEADER = {
    "data": [
        {"key": "strArray", "format": "3s3s3s", "size": 9},
        {"key": "strLenMismatch", "format": "5s", "size": 5},
    ]
}

# DTypes (int8, int16, ...) are not preserved.
# Array data are not reconstructed.
EXPECTED_DATA1_TUPLE = (3, -16, -32, -64)
EXPECTED_DATA2_TUPLE = (3, 16, 32, 64)
EXPECTED_DATA3_TUPLE = (0.32, 3, b"byte", b"c")
EXPECTED_DATA4_TUPLE = (True, b"str", 3, TIME, TIME)
EXPECTED_DATA5_TUPLE = (b"abc", b"def", b"ghi", b"jkl\x00\x00")

# DTypes (int8, int16, ...) are not preserved.
EXPECTED_DATA1_DICT = {"int8": 3, "int16": -16, "int32": -32, "int64": -64}
EXPECTED_DATA2_DICT = {"uint8": 3, "uint16": 16, "uint32": 32, "uint64": 64}
EXPECTED_DATA3_DICT = {"float32": 0.32, "float64": 3, "_byte": b"byte", "_char": b"c"}
EXPECTED_DATA4_DICT = {"bool": True, "string": b"str", "array": (3, TIME, TIME)}
EXPECTED_DATA5_DICT = {
    "strArray": (b"abc", b"def", b"ghi"),
    "strLenMismatch": b"jkl\x00\x00",
}

# DTypes (int8, int16, ...) are not preserved.
EXPECTED_DATA1_DF = pd.DataFrame(
    [(3, -16, -32, -64)], columns=["int8", "int16", "int32", "int64"]
)
EXPECTED_DATA2_DF = pd.DataFrame(
    [(3, 16, 32, 64)], columns=["uint8", "uint16", "uint32", "uint64"]
)
EXPECTED_DATA3_DF = pd.DataFrame(
    [(0.32, 3, b"byte", b"c")], columns=["float32", "float64", "_byte", "_char"]
)
EXPECTED_DATA4_DF = pd.DataFrame(
    [(True, b"str", [3, TIME, TIME])], columns=["bool", "string", "array"]
)
EXPECTED_DATA5_DF = pd.DataFrame(
    [(["abc", "def", "ghi"], "jkl\x00\x00")], columns=["strArray", "strLenMismatch"]
)

EXPECTED_DATA1_ARRAY = np.array(
    [(3, -16, -32, -64)],
    dtype=[("int8", "i1"), ("int16", "i2"), ("int32", "i4"), ("int64", "i8")],
)
EXPECTED_DATA2_ARRAY = np.array(
    [(3, 16, 32, 64)],
    dtype=[("uint8", "u1"), ("uint16", "u2"), ("uint32", "u4"), ("uint64", "u8")],
)
EXPECTED_DATA3_ARRAY = np.array(
    [(0.32, 3, b"byte", b"c")],
    dtype=[("float32", "f4"), ("float64", "f8"), ("_byte", "S4"), ("_char", "S1")],
)
EXPECTED_DATA4_ARRAY = np.array(
    [(True, b"str", [3, TIME, TIME])],
    dtype=[("bool", "?"), ("string", "S3"), ("array", "3f8")],
)
EXPECTED_DATA5_ARRAY = np.array(
    [(("abc", "def", "ghi"), "jkl\x00\x00")],
    dtype=[("strArray", "(3,)S3"), ("strLenMismatch", "S5")],
)

EXPECTED_DATA1_BYTE = b"\x03\xf0\xff\xe0\xff\xff\xff\xc0\xff\xff\xff\xff\xff\xff\xff"
EXPECTED_DATA2_BYTE = b"\x03\x10\x00 \x00\x00\x00@\x00\x00\x00\x00\x00\x00\x00"
EXPECTED_DATA3_BYTE = b"\n\xd7\xa3>\x00\x00\x00\x00\x00\x00\x08@bytec"
EXPECTED_DATA4_BYTE = (
    b"\x01str"
    b"\x00\x00\x00\x00\x00\x00\x08@\xea!\x1b\xc3\x1eJ\xd8A\xea!\x1b\xc3\x1eJ\xd8A"
)
EXPECTED_DATA5_BYTE = b"abcdefghijkl\x00\x00"


@pytest.fixture(scope="module")
def db_path(tmp_path_factory) -> Path:
    """Path to temporary database directory."""
    return tmp_path_factory.mktemp("test_db")


@pytest.mark.usefixtures("db_path")
class TestWriteDatabase:
    def test_create_table(self, db_path):
        db = necstdb.opendb(db_path, mode="w")
        db.create_table("data1", DATA1_HEADER)
        db.create_table("data2", DATA2_HEADER)
        db.create_table("data3", DATA3_HEADER)
        db.create_table("data4", DATA4_HEADER)
        db.create_table("data5", DATA5_HEADER)

    def test_write_table(self, db_path):
        db = necstdb.opendb(db_path, mode="w")
        tables = {
            name: db.open_table(name, mode="ab")
            for name in ["data1", "data2", "data3", "data4", "data5"]
        }

        _ = [tables["data1"].append(*data) for data in DATA1]
        _ = [tables["data2"].append(*data) for data in DATA2]
        _ = [tables["data3"].append(*data) for data in DATA3]

        for data in DATA4:
            flat_data = []
            _ = [
                flat_data.extend(dat)
                if isinstance(dat, list)
                else flat_data.append(dat)
                for dat in data
            ]  # Flatten the data.
            tables["data4"].append(*flat_data)
        for data in DATA5:
            flat_data = []
            _ = [
                flat_data.extend(dat)
                if isinstance(dat, list)
                else flat_data.append(dat)
                for dat in data
            ]  # Flatten the data.
            tables["data5"].append(*flat_data)

        _ = [tab.close() for tab in tables.values()]

    def test_write_file(self, db_path):
        db = necstdb.opendb(db_path, mode="w")
        files = [
            ("test.txt", "Test text."),
            ("test.txt", "Test text, file name duplicated."),
            ("test.log", b"Test text, bytes data."),
            ("test.log", b"Test text.", "Original: 127.0.0.1:/path/to/test.log"),
            ("test1.txt", "Test text.", "Original: 127.0.0.1:/path/to/test1.txt"),
        ]
        for args in files:
            db.save_file(*args)


table_name = ["data1", "data2", "data3", "data4", "data5"]


@pytest.mark.usefixtures("db_path")
class TestReadDatabase:
    def test_read_types(self, db_path):
        # Just a astype keys test.
        tuple_keys = ["tuple"]
        dict_keys = ["dict"]
        df_keys = ["pandas", "dataframe", "data_frame", "df"]
        array_keys = ["structuredarray", "structured_array", "array", "sa"]
        bytes_keys = ["buffer", "raw"]

        db = necstdb.opendb(db_path)
        for k in tuple_keys + dict_keys + df_keys + array_keys + bytes_keys:
            _ = db.open_table("data1").read(astype=k)

    def test_read_as_tuple(self, db_path):
        db = necstdb.opendb(db_path)
        actual = {name: db.open_table(name).read(astype="tuple") for name in table_name}

        assert len(actual["data1"]) == 11
        assert EXPECTED_DATA1_TUPLE == actual["data1"][3]
        assert EXPECTED_DATA2_TUPLE == actual["data2"][3]
        assert EXPECTED_DATA3_TUPLE == pytest.approx(actual["data3"][3])
        assert EXPECTED_DATA4_TUPLE == actual["data4"][3]
        with pytest.raises(TypeError):
            # Array data are not supported for tuple.
            assert len(actual["data4"][3][-1]) == 3
        assert EXPECTED_DATA5_TUPLE == actual["data5"][3]

    def test_read_as_dict(self, db_path):
        db = necstdb.opendb(db_path)
        actual = {name: db.open_table(name).read(astype="dict") for name in table_name}

        assert len(actual["data1"]) == 11
        assert EXPECTED_DATA1_DICT == actual["data1"][3]
        assert EXPECTED_DATA2_DICT == actual["data2"][3]
        assert EXPECTED_DATA3_DICT == pytest.approx(actual["data3"][3])
        assert EXPECTED_DATA4_DICT == actual["data4"][3]
        assert len(actual["data4"][3]["array"]) == 3
        assert EXPECTED_DATA5_DICT == actual["data5"][3]
        assert len(actual["data5"][3]["strArray"]) == 3

    def test_read_as_df(self, db_path):
        db = necstdb.opendb(db_path)
        actual = {name: db.open_table(name).read(astype="df") for name in table_name}

        assert len(actual["data1"]) == 11
        assert all(EXPECTED_DATA1_DF == actual["data1"].loc[3])
        assert all(EXPECTED_DATA2_DF == actual["data2"].loc[3])
        assert all(EXPECTED_DATA3_DF == actual["data3"].loc[3])
        assert all(EXPECTED_DATA4_DF == actual["data4"].loc[3])
        assert len(actual["data4"].loc[3, "array"]) == 3
        assert all(EXPECTED_DATA5_DF == actual["data5"].loc[3])
        assert len(actual["data5"].loc[3, "strArray"]) == 3

    def test_read_as_array(self, db_path):
        db = necstdb.opendb(db_path)
        actual = {name: db.open_table(name).read(astype="array") for name in table_name}

        assert len(actual["data1"]) == 11
        assert all(EXPECTED_DATA1_ARRAY == actual["data1"][3])
        assert all(EXPECTED_DATA2_ARRAY == actual["data2"][3])
        assert all(EXPECTED_DATA3_ARRAY == actual["data3"][3])
        assert all(EXPECTED_DATA4_ARRAY == actual["data4"][3])
        assert len(actual["data4"][3]["array"]) == 3
        assert EXPECTED_DATA5_ARRAY == actual["data5"][3]
        assert len(actual["data5"][3]["strArray"]) == 3

    def test_read_as_bytes(self, db_path):
        db = necstdb.opendb(db_path)
        actual = {name: db.open_table(name).read(astype="raw") for name in table_name}
        formats = ["<bhiq", "<BHIQ", "<fd4sc", "<?3s3d", "<3s3s3s5s"]
        unpacked = {
            k: tuple(struct.iter_unpack(fmt, v))
            for fmt, (k, v) in zip(formats, actual.items())
        }
        size = {k: struct.calcsize(fmt) for k, fmt in zip(actual.keys(), formats)}

        idx = {k: slice(size[k] * 3, size[k] * 4) for k in table_name}
        assert len(unpacked["data1"]) == 11
        assert EXPECTED_DATA1_BYTE == actual["data1"][idx["data1"]]
        assert EXPECTED_DATA2_BYTE == actual["data2"][idx["data2"]]
        assert EXPECTED_DATA3_BYTE == actual["data3"][idx["data3"]]
        assert EXPECTED_DATA4_BYTE == actual["data4"][idx["data4"]]
        with pytest.raises(TypeError):
            assert len(unpacked["data4"][3][-1]) == 3
        assert EXPECTED_DATA5_BYTE == actual["data5"][idx["data5"]]

    def test_read_file(self, db_path):
        db = necstdb.opendb(db_path)
        files_string = [
            ("test.txt", "Test text.", ""),
            ("test(1).txt", "Test text, file name duplicated.", ""),
            ("test.log", "Test text, bytes data.", ""),
            ("test(1).log", "Test text.", "Original: 127.0.0.1:/path/to/test.log"),
            ("test1.txt", "Test text.", "Original: 127.0.0.1:/path/to/test1.txt"),
        ]
        for filename, data, info in files_string:
            assert db.read_file(filename) == (data, info)

        files_bytes = [
            ("test.txt", b"Test text.", b""),
            ("test(1).txt", b"Test text, file name duplicated.", b""),
            ("test.log", b"Test text, bytes data.", b""),
            ("test(1).log", b"Test text.", b"Original: 127.0.0.1:/path/to/test.log"),
            ("test1.txt", b"Test text.", b"Original: 127.0.0.1:/path/to/test1.txt"),
        ]
        for filename, data, info in files_bytes:
            assert db.read_file(filename, asbytes=True) == (data, info)


@pytest.mark.usefixtures("db_path")
class TestPartialRead:
    def test_partial_read_as_tuple(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.open_table("data4").read(
            astype="tuple", start=3, num=5, cols=["array", "bool"]
        )

        assert len(actual) == 5
        with pytest.raises(AssertionError):
            # Array data are not supported for tuple.
            assert len(actual[0]) == 2
        with pytest.raises(AssertionError):
            # Data order is not preserved.
            assert actual[0] == tuple(EXPECTED_DATA4_TUPLE[idx] for idx in [2, 3, 4, 0])
        # Order insensitive matching
        assert all(val in EXPECTED_DATA4_TUPLE for val in actual[0])

    def test_partial_read_as_dict(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.open_table("data4").read(
            astype="dict", start=3, num=5, cols=["array", "bool"]
        )

        assert len(actual) == 5
        assert len(actual[0]) == 2
        _ = [print(EXPECTED_DATA4_DICT[k] for k in ["array", "bool"])]
        assert actual[0] == {k: EXPECTED_DATA4_DICT[k] for k in ["array", "bool"]}

    def test_partial_read_as_df(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.open_table("data4").read(
            astype="df", start=3, num=5, cols=["array", "bool"]
        )

        assert len(actual) == 5
        assert len(actual.loc[0]) == 2
        assert all(actual.loc[0] == EXPECTED_DATA4_DF[["array", "bool"]])

    def test_partial_read_as_array(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.open_table("data4").read(
            astype="array", start=3, num=5, cols=["array", "bool"]
        )

        assert len(actual) == 5
        assert len(actual[0]) == 2
        assert all(actual[0] == EXPECTED_DATA4_ARRAY[["array", "bool"]])

    def test_partial_read_as_bytes(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.open_table("data4").read(
            astype="raw", start=3, num=5, cols=["array", "bool"]
        )
        unpacked = tuple(struct.iter_unpack("<3d?", actual))
        size = struct.calcsize("<3d?")

        slices = [slice(8, 16), slice(16, 24), slice(24, 32), slice(0, 1)]

        assert len(actual) == size * 5
        with pytest.raises(AssertionError):
            # Array data are not supported.
            assert len(unpacked[0]) == 2
        with pytest.raises(AssertionError):
            # Data order is not preserved.
            assert actual[:size] == b"".join(
                [EXPECTED_DATA4_BYTE[idx] for idx in slices]
            )
        # Order insensitive match
        assert all(EXPECTED_DATA4_BYTE[idx] in actual for idx in slices)


@pytest.fixture(scope="module")
def archive_dir_path(tmp_path_factory) -> Path:
    """Path to a directory archive file will saved in."""
    return tmp_path_factory.mktemp("archive")


@pytest.mark.usefixtures("db_path", "archive_dir_path")
class TestMethods:
    def test_list_tables(self, db_path):
        db = necstdb.opendb(db_path)
        assert db.list_tables() == ["data1", "data2", "data3", "data4", "data5"]

    def test_checkout(self, db_path, archive_dir_path):
        db = necstdb.opendb(db_path)
        save_path = archive_dir_path / "archive.tar.gz"
        db.checkout(saveto=save_path, compression="gz")

        assert save_path.exists()

    def test_get_info(self, db_path):
        db = necstdb.opendb(db_path)
        actual = db.get_info()
        expected = pd.DataFrame(
            [
                ("data1", 165, 11, 15, "<bhiq"),
                ("data2", 330, 22, 15, "<BHIQ"),
                ("data3", 594, 33, 17, "<fd4sc"),
                ("data4", 1364, 44, 28, "<?3s3d"),
                ("data5", 495, 55, 14, "<3s3s3s5s"),
            ],
            columns=[
                "table name",
                "file size [byte]",
                "#records",
                "record size [byte]",
                "format",
            ],
        ).set_index("table name")

        assert all(actual.index == expected.index)
        assert all(actual["#records"] == expected["#records"])
        assert all(actual["record size [byte]"] == expected["record size [byte]"])
        assert all(actual["format"] == expected["format"])
